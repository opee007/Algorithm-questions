<!DOCTYPE html>
<html>
<head>
<title>offer++.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#">排序算法总结</a></li>
</ol>
<ul>
<li>1.1. <a href="#bubbleSortOn2">冒泡排序 bubbleSort O(n^2) 稳定</a></li>
<li>1.2. <a href="#quickSortOnlogn">快速排序 quickSort O(nlogn)</a></li>
<li>1.3. <a href="#insertSortOn2">插入排序 insertSort O(n^2) 稳定</a></li>
<li>1.4. <a href="#selectSortOn2">选择排序 selectSort O(n^2)</a></li>
<li>1.5. <a href="#mergeSortOnlogn">归并排序 mergeSort O(nlogn) 稳定</a></li>
<li>1.6. <a href="#heapSortOnlogn">堆排序 heapSort O(nlogn)</a></li>
</ul>
</li>
<li>
<ol start="2">
<li><a href="#Offer">剑指Offer</a></li>
</ol>
<ul>
<li>2.1. <a href="#duplicateInArray">找出数组中重复数字 duplicateInArray</a></li>
<li>2.2. <a href="#duplicateInArray2">不修改数组找出重复的数字 duplicateInArray2</a></li>
<li>2.3. <a href="#findNumberIn2DArray">二维数组查找 findNumberIn2DArray</a></li>
<li>2.4. <a href="#20replaceSpaces">替换空格为%20  replaceSpaces</a></li>
<li>2.5. <a href="#printListReversingly">从尾到头打印链表 printListReversingly</a></li>
<li>2.6. <a href="#buildTree">前序和中序遍历重建二叉树 buildTree</a></li>
<li>2.7. <a href="#fatherinorderSuccessor">二叉树的下一个结点（给定father结点） inorderSuccessor</a></li>
<li>2.8. <a href="#2stack2queue">两个栈实现一个队列 2stack2queue</a></li>
<li>2.9. <a href="#Fibonacci">斐波那契数列 Fibonacci</a></li>
<li>2.10. <a href="#minArray">旋转数组的最小数字（二分查找） minArray</a></li>
<li>2.11. <a href="#DFSexistpath">矩阵中的路径（DFS路径） existpath</a></li>
<li>2.12. <a href="#bfsmovingCount">机器人的运动范围（bfs搜索） movingCount</a></li>
<li>2.13. <a href="#maxProductAfterCutting">剪绳子（分段最大乘积） maxProductAfterCutting</a></li>
<li>2.14. <a href="#1unsignedintn_nNumberOf1">二进制中1的个数（unsigned int n = _n;） NumberOf1</a></li>
<li>2.15. <a href="#powPower">实现数值的整数次方，即pow() Power</a></li>
<li>2.16. <a href="#O1deleteNode">在O(1)时间删除链表结点 deleteNode</a></li>
<li>2.17. <a href="#deleteDuplication">删除链表中重复的节点 deleteDuplication</a></li>
<li>2.18. <a href="#isMatch">正则表达式匹配 isMatch</a></li>
<li>2.19. <a href="#isNumber">表示数值的字符串 isNumber</a></li>
<li>2.20. <a href="#reOrderArray">调整数组顺序使奇数位于偶数前面 reOrderArray</a></li>
<li>2.21. <a href="#kfindKthToTail">链表中倒数第k个节点 findKthToTail</a></li>
<li>2.22. <a href="#entryNodeOfLoop">寻找环形链表入口 entryNodeOfLoop</a></li>
<li>2.23. <a href="#reverseList">翻转链表 reverseList</a>
<ul>
<li>2.23.1. <a href="#1r1">(1)迭代 r1</a></li>
<li>2.23.2. <a href="#2r2">(2) 递归 r2</a></li>
</ul>
</li>
<li>2.24. <a href="#merge">合并两个排序的链表 merge</a></li>
<li>2.25. <a href="#BAhasSubtree">树的子结构(判断B是不是A的子结构) hasSubtree</a></li>
<li>2.26. <a href="#mirror">二叉树的镜像 mirror</a></li>
<li>2.27. <a href="#isSymmetric">判断对称（镜像）的二叉树 isSymmetric</a></li>
<li>2.28. <a href="#printMatrix">顺时针打印矩阵 printMatrix</a></li>
<li>2.29. <a href="#minMinStack">包含min函数的栈 MinStack</a></li>
<li>2.30. <a href="#isPopOrder">栈的压入、弹出序列 isPopOrder</a></li>
<li>2.31. <a href="#printFromTopToBottom1">不分行从上往下打印二叉树(层次遍历) printFromTopToBottom1</a></li>
<li>2.32. <a href="#printFromTopToBottom2">分行从上往下打印二叉树 printFromTopToBottom2</a></li>
<li>2.33. <a href="#printFromTopToBottom3">之字形打印二叉树 printFromTopToBottom3</a></li>
<li>2.34. <a href="#treePathSum">二叉树中和为某一值的路径(回溯) treePathSum</a></li>
<li>2.35. <a href="#verifySequenceOfBST">二叉搜索树的后序遍历序列 verifySequenceOfBST</a></li>
<li>2.36. <a href="#treeFindPath1">二叉树中和为某一值的路径 treeFindPath1</a></li>
<li>2.37. <a href="#-1">复杂链表的复刻</a></li>
<li>2.38. <a href="#strToInt">字符串转数字 strToInt</a></li>
<li>2.39. <a href="#lastRemaining">约瑟夫坏（圆圈中最后剩下的） lastRemaining</a>
<ul>
<li>2.39.1. <a href="#l1">暴力模拟 l1</a></li>
<li>2.39.2. <a href="#l2">递推 l2</a></li>
</ul>
</li>
<li>2.40. <a href="#isContinuous">扑克牌顺子 isContinuous</a></li>
<li>2.41. <a href="#Router">一排路由器可以覆盖的信号 Router</a></li>
<li>2.42. <a href="#slide">滑动窗口最大值 slide</a></li>
<li>2.43. <a href="#BiA0A1An-1">乘积数组 B[i]=A[0]×A[1]…×A[n-1]</a></li>
<li>2.44. <a href="#maxProduct">分裂二叉树最大乘积 maxProduct</a></li>
<li>2.45. <a href="#lowestCommonAncestor1">二叉树最低公共祖先 lowestCommonAncestor1</a></li>
<li>2.46. <a href="#BigMutiple">大数相乘 BigMutiple</a></li>
<li>2.47. <a href="#bigAdd">大数相加 bigAdd</a></li>
<li>2.48. <a href="#bitopAdd">不用加减乘除做加法 bitopAdd</a></li>
</ul>
</li>
<li>
<ol start="3">
<li><a href="#LeetCode">LeetCode</a></li>
</ol>
<ul>
<li>3.1. <a href="#twoSum">1.两数之和 twoSum</a></li>
<li>3.2. <a href="#addTwoNumbers">2. 两数相加 addTwoNumbers</a></li>
<li>3.3. <a href="#lengthOfLongestSubstring">3. 无重复字符的最长子串 lengthOfLongestSubstring</a></li>
<li>3.4. <a href="#findMedianSortedArrays">4. 寻找两个正序数组的中位数 findMedianSortedArrays</a></li>
<li>3.5. <a href="#longestPalindrome">5. 最长回文子串 longestPalindrome</a></li>
<li>3.6. <a href="#ZzConvert">6. Z 字形变换 zConvert</a></li>
<li>3.7. <a href="#intReverse">7. 整数反转 intReverse</a></li>
<li>3.8. <a href="#atoi">8. 字符串转换整数 (atoi)</a></li>
<li>3.9. <a href="#isPalindrome1">9. 回文数 isPalindrome1</a></li>
<li>3.10. <a href="#isMatchq">10. 正则表达式匹配 isMatch q</a></li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#landproblem">岛屿问题 land problem</a></li>
</ol>
<ul>
<li>4.1. <a href="#numIslands">岛屿数量 numIslands</a></li>
<li>4.2. <a href="#maxAreaOfIsland">岛屿的最大面积 maxAreaOfIsland</a></li>
<li>4.3. <a href="#islandPerimeter">岛屿的周长 islandPerimeter</a></li>
</ul>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc --># offer++
<h2 id="1-a-namea%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93">1. <a name=''></a>排序算法总结</h2>
<h3 id="11-a-namebubblesorton2a%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-bubblesort-on2-%E7%A8%B3%E5%AE%9A">1.1. <a name='bubbleSortOn2'></a>冒泡排序 bubbleSort O(n^2) 稳定</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)
        {
            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) swap(a[j], a[j + <span class="hljs-number">1</span>]);
        }
    }
}
</div></code></pre>
<h3 id="12-a-namequicksortonlogna%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quicksort-onlogn">1.2. <a name='quickSortOnlogn'></a>快速排序 quickSort O(nlogn)</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span>
</span>{
    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> i = l, j = r, tmp = a[l];

    <span class="hljs-keyword">while</span> (i &lt; j)
    {
        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= tmp) j--;
        <span class="hljs-keyword">if</span> (i &lt; j) a[i++] = a[j];
        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= tmp) i++;
        <span class="hljs-keyword">if</span> (i &lt; j) a[j--] = a[i];
    }
    a[i] = tmp;
    quickSort(a, l, i - <span class="hljs-number">1</span>);
    quickSort(a, i + <span class="hljs-number">1</span>, r);
}
</div></code></pre>
<h3 id="13-a-nameinsertsorton2a%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-insertsort-on2-%E7%A8%B3%E5%AE%9A">1.3. <a name='insertSortOn2'></a>插入排序 insertSort O(n^2) 稳定</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)
    {
        <span class="hljs-keyword">int</span> tmp = a[i], j;
        <span class="hljs-keyword">for</span> (j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; a[j - <span class="hljs-number">1</span>]; j--)
            a[j] = a[j - <span class="hljs-number">1</span>];
        a[j] = tmp;
    }
}
</div></code></pre>
<h3 id="14-a-nameselectsorton2a%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-selectsort-on2">1.4. <a name='selectSortOn2'></a>选择排序 selectSort O(n^2)</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)
        {
            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) swap(a[i], a[j]);
        }
    }
}
</div></code></pre>
<h3 id="15-a-namemergesortonlogna%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-mergesort-onlogn-%E7%A8%B3%E5%AE%9A">1.5. <a name='mergeSortOnlogn'></a>归并排序 mergeSort O(nlogn) 稳定</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span>
</span>{
    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> tmp[r - l + <span class="hljs-number">1</span>];

    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
    mergeSort(a, l, mid), mergeSort(a, mid + <span class="hljs-number">1</span>, r);

    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)
        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) tmp[k++] = a[i++];
        <span class="hljs-keyword">else</span> tmp[k++] = a[j++];

    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];
    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = a[j++];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) a[i] = tmp[j];
}
</div></code></pre>
<h3 id="16-a-nameheapsortonlogna%E5%A0%86%E6%8E%92%E5%BA%8F-heapsort-onlogn">1.6. <a name='heapSortOnlogn'></a>堆排序 heapSort O(nlogn)</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> l = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> r = x * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = x;

    <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; a[l] &gt; a[<span class="hljs-built_in">max</span>]) <span class="hljs-built_in">max</span> = l;
    <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; a[r] &gt; a[<span class="hljs-built_in">max</span>]) <span class="hljs-built_in">max</span> = r;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span> != x)
    {
        swap(a[x], a[<span class="hljs-built_in">max</span>]);
        adjust_heap(a, <span class="hljs-built_in">max</span>, n);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        adjust_heap(a, i, n);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)
    {
        swap(a[<span class="hljs-number">0</span>], a[i]);
        adjust_heap(a, <span class="hljs-number">0</span>, i);
    }
}
</div></code></pre>
<h2 id="2-a-nameoffera%E5%89%91%E6%8C%87offer">2. <a name='Offer'></a>剑指Offer</h2>
<h3 id="21-a-nameduplicateinarraya%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97-duplicateinarray">2.1. <a name='duplicateInArray'></a>找出数组中重复数字 duplicateInArray</h3>
<p>给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。&lt;&gt;</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。</span>
<span class="hljs-comment">// 返回 2 或 3。</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicateInArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span> || nums[i] &gt;n<span class="hljs-number">-1</span>) 
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-comment">// 原地交换</span>
            <span class="hljs-keyword">while</span>(i != nums[i]){
                <span class="hljs-comment">//　把nums[i]换到正确的位置 </span>
                <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) <span class="hljs-keyword">return</span> nums[i];
                swap(nums[i], nums[nums[i]]);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
};
</div></code></pre>
<h3 id="22-a-nameduplicateinarray2a%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-duplicateinarray2">2.2. <a name='duplicateInArray2'></a>不修改数组找出重复的数字 duplicateInArray2</h3>
<p>给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。请找出数组中任意一个重复的数，但不能修改输入的数组。<a href="https://www.acwing.com/problem/content/description/15/">https://www.acwing.com/problem/content/description/15/</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicateInArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(l &lt; r){
            <span class="hljs-keyword">int</span> mid = r + l &gt;&gt; <span class="hljs-number">1</span>;
            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: nums) <span class="hljs-keyword">if</span>(x &gt;= l &amp;&amp; x &lt;= mid) s++;
            <span class="hljs-keyword">if</span>(s &gt; mid - l + <span class="hljs-number">1</span>) r = mid;
            <span class="hljs-keyword">else</span> l = mid +<span class="hljs-number">1</span>;
         }
         <span class="hljs-keyword">return</span> r;
    }
};
</div></code></pre>
<h3 id="23-a-namefindnumberin2darraya%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE-findnumberin2darray">2.3. <a name='findNumberIn2DArray'></a>二维数组查找 findNumberIn2DArray</h3>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-comment">// 从右上角开始遍历</span>
        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(i&lt;matrix.<span class="hljs-built_in">size</span>() &amp;&amp; j&gt;=<span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span>(matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) i++;
            <span class="hljs-keyword">else</span> j--;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    }
};
</div></code></pre>
<h3 id="24-a-name20replacespacesa%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E4%B8%BA20-replacespaces">2.4. <a name='20replaceSpaces'></a>替换空格为%20  replaceSpaces</h3>
<p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpaces</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;str)</span> </span>{
        <span class="hljs-keyword">int</span> l = str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-comment">// 不开新的数组</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: str){
            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">' '</span>){
                str += <span class="hljs-string">"00"</span>;
            }
        }
        <span class="hljs-keyword">int</span> l2 = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; 
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &gt;= <span class="hljs-number">0</span>; i--){
            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">' '</span>){
                str[l2--] = <span class="hljs-string">'0'</span>; 
                str[l2--] = <span class="hljs-string">'2'</span>; 
                str[l2--] = <span class="hljs-string">'%'</span>; 
            }
            <span class="hljs-keyword">else</span>{
                str[l2--] = str[i];
            }
        }
        <span class="hljs-keyword">return</span> str;
    }
};
</div></code></pre>
<h3 id="25-a-nameprintlistreversinglya%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-printlistreversingly">2.5. <a name='printListReversingly'></a>从尾到头打印链表 printListReversingly</h3>
<p>输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。返回的结果用数组存储。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListReversingly</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">while</span>(head){
            ans.push_back(head-&gt;val);
            head = head-&gt;next;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(ans.rbegin(), ans.rend());
    }
};
</div></code></pre>
<h3 id="26-a-namebuildtreea%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-buildtree">2.6. <a name='buildTree'></a>前序和中序遍历重建二叉树 buildTree</h3>
<p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>{
        <span class="hljs-keyword">return</span> dfs(preorder, inorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
    }

    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> ps, <span class="hljs-keyword">int</span> pend, <span class="hljs-keyword">int</span> is, <span class="hljs-keyword">int</span> iend)</span></span>{
        <span class="hljs-keyword">if</span>(ps &gt; pend) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(preorder[ps]);
        <span class="hljs-keyword">int</span> l = is;
        <span class="hljs-keyword">while</span>(inorder[l] != preorder[ps]) l++;
        <span class="hljs-keyword">int</span> left=l-is;   <span class="hljs-comment">//左子树的长度</span>
        <span class="hljs-keyword">int</span> right=iend-l;  <span class="hljs-comment">//右子树长度</span>
        root-&gt;left = dfs(preorder, inorder, ps + <span class="hljs-number">1</span>, ps + left, is, l - <span class="hljs-number">1</span>);
        root-&gt;right = dfs(preorder, inorder, ps + <span class="hljs-number">1</span> + left, pend, l+<span class="hljs-number">1</span>, iend);
        <span class="hljs-keyword">return</span> root;
    }
};
</div></code></pre>
<h3 id="27-a-namefatherinordersuccessora%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E7%BB%99%E5%AE%9Afather%E7%BB%93%E7%82%B9-inordersuccessor">2.7. <a name='fatherinorderSuccessor'></a>二叉树的下一个结点（给定father结点） inorderSuccessor</h3>
<p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。（给定father结点）</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>{
        <span class="hljs-comment">// 有无右子树讨论</span>
        <span class="hljs-keyword">if</span> (p-&gt;right) {
            p = p-&gt;right;
            <span class="hljs-keyword">while</span> (p-&gt;left) p = p-&gt;left;
            <span class="hljs-keyword">return</span> p;
        }
        <span class="hljs-comment">// 如果p是father的右儿子，继续往上找</span>
        <span class="hljs-keyword">while</span> (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;
        <span class="hljs-keyword">return</span> p-&gt;father;
    }
};
</div></code></pre>
<h3 id="28-a-name2stack2queuea%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97-2stack2queue">2.8. <a name='2stack2queue'></a>两个栈实现一个队列 2stack2queue</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1, s2;
    CQueue() {
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        s1.push(value);
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(s2.empty()){
            <span class="hljs-keyword">while</span>(!s1.empty()){
            <span class="hljs-keyword">int</span> temp = s1.top();
            s2.push(temp);
            s1.pop();
            }
        }
        <span class="hljs-keyword">if</span>(s2.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">int</span> temp = s2.top();
        s2.pop();
        <span class="hljs-keyword">return</span> temp;
    }
};
</div></code></pre>
<h3 id="29-a-namefibonaccia%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-fibonacci">2.9. <a name='Fibonacci'></a>斐波那契数列 Fibonacci</h3>
<p>假定从0开始，第0项为0。(n&lt;=39)</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(--n){
            <span class="hljs-keyword">int</span> c = a + b;
            a = b; 
            b = c;
        }
        <span class="hljs-keyword">return</span> b;
    }
};
</div></code></pre>
<h3 id="210-a-nameminarraya%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-minarray">2.10. <a name='minArray'></a>旋转数组的最小数字（二分查找） minArray</h3>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个升序（非降序）的数组的一个旋转，输出旋转数组的最小元素。
<a href="https://www.acwing.com/solution/content/727/">https://www.acwing.com/solution/content/727/</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; nums[n] == nums[<span class="hljs-number">0</span>]) n -- ;
        <span class="hljs-keyword">if</span> (nums[n] &gt;= nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
        <span class="hljs-keyword">while</span> (l &lt; r) {
            <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">// [l, mid], [mid + 1, r]</span>
            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[<span class="hljs-number">0</span>]) r = mid;
            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> nums[r];
    }
};
</div></code></pre>
<h3 id="211-a-namedfsexistpatha%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84dfs%E8%B7%AF%E5%BE%84-existpath">2.11. <a name='DFSexistpath'></a>矩阵中的路径（DFS路径） existpath</h3>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; matrix, <span class="hljs-built_in">string</span> w)</span> </span>{
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j &lt; m; j++){
                <span class="hljs-keyword">if</span>(dfs(matrix, w, <span class="hljs-number">0</span>, i, j)){
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; matrix, <span class="hljs-built_in">string</span>&amp; w, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>{
        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= matrix.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || matrix[i][j] != w[u]){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span>(u == w.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">char</span> t = matrix[i][j];
        <span class="hljs-comment">// 回溯</span>
        matrix[i][j] = <span class="hljs-string">'*'</span>;
        <span class="hljs-keyword">bool</span> ans = dfs(matrix, w, u+<span class="hljs-number">1</span>, i<span class="hljs-number">-1</span>, j)||
                dfs(matrix, w, u+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>, j)||
                dfs(matrix, w, u+<span class="hljs-number">1</span>, i, j<span class="hljs-number">-1</span>)||
                dfs(matrix, w, u+<span class="hljs-number">1</span>, i, j+<span class="hljs-number">1</span>);
        matrix[i][j] = t;
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="212-a-namebfsmovingcounta%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4bfs%E6%90%9C%E7%B4%A2-movingcount">2.12. <a name='bfsmovingCount'></a>机器人的运动范围（bfs搜索） movingCount</h3>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(x){
            ans += x % <span class="hljs-number">10</span>;
            x /= <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">while</span>(y){
            ans += y % <span class="hljs-number">10</span>;
            y /= <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 标记数组</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">st</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(m))</span></span>;
        <span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;
        q.push({<span class="hljs-number">0</span>,<span class="hljs-number">0</span>});
        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}, dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// BFS</span>
        <span class="hljs-keyword">while</span>(!q.empty()){
            <span class="hljs-keyword">auto</span> x = q.front();
            q.pop();
            <span class="hljs-keyword">if</span>(get_num(x.first, x.second) &lt;= k  &amp;&amp; st[x.first][x.second] == <span class="hljs-literal">false</span>){
                ans ++;
                st[x.first][x.second] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){
                    <span class="hljs-keyword">if</span>(x.first+dx[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; x.first+dx[i] &lt; n &amp;&amp;  x.second+ dy[i] &gt;=<span class="hljs-number">0</span> &amp;&amp; x.second+ dy[i] &lt; m){
                        q.push({x.first+dx[i], x.second+ dy[i]});
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="213-a-namemaxproductaftercuttinga%E5%89%AA%E7%BB%B3%E5%AD%90%E5%88%86%E6%AE%B5%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-maxproductaftercutting">2.13. <a name='maxProductAfterCutting'></a>剪绳子（分段最大乘积） maxProductAfterCutting</h3>
<p>给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProductAfterCutting</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>{
        <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * (length<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">if</span>(length % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, length / <span class="hljs-number">3</span>);
        <span class="hljs-keyword">if</span>(length % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, length / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;
        <span class="hljs-keyword">if</span>(length % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, length / <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>;
    }
};
</div></code></pre>
<h3 id="214-a-name1unsignedintnnnumberof1a%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0unsigned-int-n--n-numberof1">2.14. <a name='1unsignedintn_nNumberOf1'></a>二进制中1的个数（unsigned int n = _n;） NumberOf1</h3>
<p>输入一个32位整数，输出该数二进制表示中1的个数。
注意：负数在计算机中用其绝对值的补码来表示。
补码：如果我们指定了这个数据是unsigned类型的，意思就是说不将这个数据以补码的形式来读取。而是以纯二进制来读取。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _n)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 如果是负数，右移高位补１，则死循环，而无符号整数在高位补０。</span>
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = _n;
        <span class="hljs-keyword">while</span>(n){
            ans += (n &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>;
            n &gt;&gt;= <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="215-a-namepowpowera%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E5%8D%B3pow-power">2.15. <a name='powPower'></a>实现数值的整数次方，即pow() Power</h3>
<p>实现函数double Power(double base, int exponent)，求base的 exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>{
        <span class="hljs-keyword">double</span> ans = <span class="hljs-number">1.0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">abs</span>(exponent);
        <span class="hljs-keyword">while</span>(n){
            <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) ans *= base;
            base *= base;
            n &gt;&gt;= <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / ans;
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="216-a-nameo1deletenodea%E5%9C%A8o1%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9-deletenode">2.16. <a name='O1deleteNode'></a>在O(1)时间删除链表结点 deleteNode</h3>
<p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。假设链表一定存在，并且该节点一定不是尾节点。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>{
        node-&gt;val = node-&gt;next-&gt;val;
        ListNode *t = node-&gt;next;
        node-&gt;next = node-&gt;next-&gt;next;
        <span class="hljs-keyword">delete</span> t;
    }
};
</div></code></pre>
<h3 id="217-a-namedeleteduplicationa%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9-deleteduplication">2.17. <a name='deleteDuplication'></a>删除链表中重复的节点 deleteDuplication</h3>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。(一个都不留)
输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出：1-&gt;2-&gt;5</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        dummy-&gt;next = head;

        <span class="hljs-keyword">auto</span> p = dummy;
        <span class="hljs-keyword">while</span> (p-&gt;next) {
            <span class="hljs-keyword">auto</span> q = p-&gt;next;
            <span class="hljs-keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;

            <span class="hljs-keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next;
            <span class="hljs-keyword">else</span> p-&gt;next = q;
        }

        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }
};
</div></code></pre>
<h3 id="218-a-nameismatcha%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-ismatch">2.18. <a name='isMatch'></a>正则表达式匹配 isMatch</h3>
<p>请实现一个函数用来匹配包括'.'和'<em>'的正则表达式。模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。
例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>{
        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = p.<span class="hljs-built_in">size</span>();
        s = <span class="hljs-string">' '</span> +s; p = <span class="hljs-string">' '</span> + p;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(m+<span class="hljs-number">1</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>; j &lt;= m; j++){
                <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt;= m &amp;&amp; p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">if</span>(i &amp;&amp; p[j] != <span class="hljs-string">'*'</span>){
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; (s[i] == p[j] || p[j] ==<span class="hljs-string">'.'</span>);
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-string">'*'</span>){
                    dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || i &amp;&amp; dp[i<span class="hljs-number">-1</span>][j] &amp;&amp; (s[i] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">'.'</span>);
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[n][m];
    }
};
</div></code></pre>
<h3 id="219-a-nameisnumbera%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-isnumber">2.19. <a name='isNumber'></a>表示数值的字符串 isNumber</h3>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">' '</span>) i ++ ;
        <span class="hljs-keyword">int</span> j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[j] == <span class="hljs-string">' '</span>) j -- ;
        <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        s = s.substr(i, j - i + <span class="hljs-number">1</span>);

        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">'+'</span>) s = s.substr(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (s.empty() || s[<span class="hljs-number">0</span>] == <span class="hljs-string">'.'</span> &amp;&amp; s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">int</span> dot = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ )
        {
            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'9'</span>);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'.'</span>)
            {
                dot ++ ;
                <span class="hljs-keyword">if</span> (e || dot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'e'</span> || s[i] == <span class="hljs-string">'E'</span>)
            {
                e ++ ;
                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == s.<span class="hljs-built_in">size</span>() || !i || e &gt; <span class="hljs-number">1</span> || i == <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">'.'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'+'</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'-'</span>)
                {
                    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    i ++ ;
                }
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment"># python代码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: bool
        """</span>
        <span class="hljs-keyword">try</span>:
            float(s)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</div></code></pre>
<h3 id="220-a-namereorderarraya%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-reorderarray">2.20. <a name='reOrderArray'></a>调整数组顺序使奇数位于偶数前面 reOrderArray</h3>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。
样例
输入：[1,2,3,4,5]
输出: [1,3,5,2,4]</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;<span class="hljs-built_in">array</span>)</span> </span>{
         <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
         <span class="hljs-keyword">while</span>(left &lt; right){
            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; <span class="hljs-built_in">array</span>[left] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) left++;
            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; <span class="hljs-built_in">array</span>[right] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) right--;
            <span class="hljs-keyword">if</span>(left &lt; right) swap(<span class="hljs-built_in">array</span>[left], <span class="hljs-built_in">array</span>[right]);
            left++;
            right--;
        }
    }
};
</div></code></pre>
<h3 id="221-a-namekfindkthtotaila%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-findkthtotail">2.21. <a name='kfindKthToTail'></a>链表中倒数第k个节点 findKthToTail</h3>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>注意：
k &gt;= 0;
如果k大于链表长度，则返回 NULL;</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">findKthToTail</span><span class="hljs-params">(ListNode* pListHead, <span class="hljs-keyword">int</span> k)</span> </span>{
        ListNode *p = pListHead;
        <span class="hljs-keyword">int</span> llen = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(p){
            llen++;
            p = p-&gt;next;
        }
        <span class="hljs-keyword">if</span>(k&gt;llen) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        p = pListHead;
        <span class="hljs-keyword">int</span> t = llen -k;
        <span class="hljs-keyword">while</span>(t--){
            p = p-&gt;next;
        }
        <span class="hljs-keyword">return</span> p;
    }
};
</div></code></pre>
<h3 id="222-a-nameentrynodeofloopa%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%85%A5%E5%8F%A3-entrynodeofloop">2.22. <a name='entryNodeOfLoop'></a>寻找环形链表入口 entryNodeOfLoop</h3>
<pre class="hljs"><code><div><span class="hljs-comment">/*
用两个指针 first,second 分别从起点开始走，first 每次走一步，second 每次走两步。如果过程中 second 走到null，则说明不存在环。否则当 first 和 second 相遇后，让 first 返回起点，second 待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口。
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>{
        ListNode *first = head, *second = head;
        <span class="hljs-keyword">while</span>(first &amp;&amp; second){
            first = first-&gt;next;
            <span class="hljs-keyword">if</span>(second-&gt;next-&gt;next) second = second-&gt;next-&gt;next;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            <span class="hljs-keyword">if</span>(first == second) <span class="hljs-keyword">break</span>;
        }
        first = head;
        <span class="hljs-keyword">while</span>(first != second){
            first = first-&gt;next;
            second = second-&gt;next;
        }
        <span class="hljs-keyword">return</span> first;
    }
};
</div></code></pre>
<h3 id="223-a-namereverselista%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-reverselist">2.23. <a name='reverseList'></a>翻转链表 reverseList</h3>
<h4 id="2231-a-name1r1a1%E8%BF%AD%E4%BB%A3-r1">2.23.1. <a name='1r1'></a>(1)迭代 r1</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        ListNode *pre = <span class="hljs-literal">NULL</span>, *p = head;
        <span class="hljs-keyword">while</span>(p){
            ListNode *t = <span class="hljs-literal">NULL</span>;
            <span class="hljs-keyword">if</span>(p-&gt;next) t = p-&gt;next;
            p-&gt;next = pre;
            pre = p;
            p = t;
        }
        <span class="hljs-keyword">return</span> pre;
    }
};
</div></code></pre>
<h4 id="2232-a-name2r2a2-%E9%80%92%E5%BD%92-r2">2.23.2. <a name='2r2'></a>(2) 递归 r2</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) {
            <span class="hljs-keyword">return</span> head;
        }
        ListNode* ret = reverseList(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> ret;
    }
};
</div></code></pre>
<h3 id="224-a-namemergea%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-merge">2.24. <a name='merge'></a>合并两个排序的链表 merge</h3>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        ListNode *dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">auto</span> p = dummy;
        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2){
            <span class="hljs-keyword">if</span>(l1 -&gt;val &lt; l2-&gt;val){
                p-&gt;next = l1;
                l1 = l1-&gt;next;
            }
            <span class="hljs-keyword">else</span>{
                p-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            p = p-&gt;next;
        }
        <span class="hljs-keyword">if</span>(l1) p-&gt;next = l1; <span class="hljs-keyword">else</span> p-&gt;next = l2;
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }  
};
</div></code></pre>
<h3 id="225-a-namebahassubtreea%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E5%88%A4%E6%96%ADb%E6%98%AF%E4%B8%8D%E6%98%AFa%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84-hassubtree">2.25. <a name='BAhasSubtree'></a>树的子结构(判断B是不是A的子结构) hasSubtree</h3>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。我们规定空树不是任何树的子结构。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>{
        <span class="hljs-keyword">if</span> (!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (isSame(pRoot1, pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>{
        <span class="hljs-keyword">if</span> (!pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (!pRoot1 || pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isSame(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSame(pRoot1-&gt;right, pRoot2-&gt;right);
    }
};
</div></code></pre>
<h3 id="226-a-namemirrora%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F-mirror">2.26. <a name='mirror'></a>二叉树的镜像 mirror</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;
        TreeNode *t = root-&gt;left;
        root-&gt;left = root-&gt;right;
        root-&gt;right = t;
        mirror(root-&gt;left);
        mirror(root-&gt;right);
    }
};
</div></code></pre>
<h3 id="227-a-nameissymmetrica%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E9%95%9C%E5%83%8F%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-issymmetric">2.27. <a name='isSymmetric'></a>判断对称（镜像）的二叉树 isSymmetric</h3>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。
如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> dfs(root-&gt;left, root-&gt;right);
    }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *q, TreeNode *p)</span></span>{
        <span class="hljs-comment">// 搜索到没有最底部</span>
        <span class="hljs-keyword">if</span>(!q &amp;&amp; !p) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(!q || !p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span>(q-&gt;val != p-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> dfs(q-&gt;left, p-&gt;right) &amp;&amp; dfs(q-&gt;right, p-&gt;left);
    }
};
</div></code></pre>
<h3 id="228-a-nameprintmatrixa%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5-printmatrix">2.28. <a name='printMatrix'></a>顺时针打印矩阵 printMatrix</h3>
<pre class="hljs"><code><div><span class="hljs-comment">/*
输入：
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;
        <span class="hljs-keyword">if</span> (matrix.empty()) <span class="hljs-keyword">return</span> res;
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">st</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(m, <span class="hljs-literal">false</span>))</span></span>;
        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n * m; k ++ )
        {
            res.push_back(matrix[x][y]);
            st[x][y] = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">int</span> a = x + dx[d], b = y + dy[d];
            <span class="hljs-comment">// 碰壁就改变方向； </span>
            <span class="hljs-keyword">if</span> (x + dx[d] &lt; <span class="hljs-number">0</span> || x + dx[d] &gt;= n || y + dy[d] &lt; <span class="hljs-number">0</span> || y + dy[d] &gt;= m || st[a][b]) d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;
            x = x + dx[d], y = y + dy[d];
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</div></code></pre>
<h3 id="229-a-nameminminstacka%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-minstack">2.29. <a name='minMinStack'></a>包含min函数的栈 MinStack</h3>
<p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。<br>
push(x)–将元素x插入栈中<br>
pop()–移除栈顶元素<br>
top()–得到栈顶元素<br>
getMin()–得到栈中最小元素</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    <span class="hljs-comment">// 维护一个单调栈s2; </span>
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1, s2;
    MinStack() {
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        <span class="hljs-keyword">if</span>(s2.empty() || x&lt;=s2.top()) s2.push(x);
        s1.push(x);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(s1.top() == s2.top()) s2.pop();
        s1.pop();
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> s1.top();
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> s2.top();
    }
};
</div></code></pre>
<h3 id="230-a-nameispopordera%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97-ispoporder">2.30. <a name='isPopOrder'></a>栈的压入、弹出序列 isPopOrder</h3>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>
注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPopOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pushV,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;
        <span class="hljs-keyword">if</span>(pushV.<span class="hljs-built_in">size</span>() != popV.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : pushV){
            s.push(i);
            <span class="hljs-keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[j]){
                s.pop();
                j++;
            }

        }
        <span class="hljs-keyword">return</span> s.empty();
    }
};
</div></code></pre>
<h3 id="231-a-nameprintfromtoptobottom1a%E4%B8%8D%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-printfromtoptobottom1">2.31. <a name='printFromTopToBottom1'></a>不分行从上往下打印二叉树(层次遍历) printFromTopToBottom1</h3>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;
        q.push(root);
        <span class="hljs-keyword">while</span>(!q.empty()){
            <span class="hljs-keyword">if</span>(q.front()-&gt;left) q.push(q.front()-&gt;left);
            <span class="hljs-keyword">if</span>(q.front()-&gt;right) q.push(q.front()-&gt;right);
            ans.push_back(q.front()-&gt;val);
            q.pop();
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="232-a-nameprintfromtoptobottom2a%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-printfromtoptobottom2">2.32. <a name='printFromTopToBottom2'></a>分行从上往下打印二叉树 printFromTopToBottom2</h3>
<p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;
        <span class="hljs-built_in">queue</span> &lt;TreeNode*&gt; q;
        q.push(root);
        <span class="hljs-keyword">while</span>(!q.empty()){
            <span class="hljs-keyword">int</span> q_long = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
            <span class="hljs-keyword">while</span>(q_long--){
                <span class="hljs-keyword">if</span>(q.front()-&gt;left) q.push(q.front()-&gt;left);
                <span class="hljs-keyword">if</span>(q.front()-&gt;right) q.push(q.front()-&gt;right);
                temp.push_back(q.front()-&gt;val);
                q.pop();
            }
            ans.push_back(temp);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="233-a-nameprintfromtoptobottom3a%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-printfromtoptobottom3">2.33. <a name='printFromTopToBottom3'></a>之字形打印二叉树 printFromTopToBottom3</h3>
<p>请实现一个函数按照之字形顺序从上向下打印二叉树。<br>
即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;
        <span class="hljs-comment">// 主要认识双端队列</span>
        <span class="hljs-comment">// 单端：queue  双端：deque</span>
        <span class="hljs-built_in">deque</span> &lt;TreeNode*&gt; q;
        q.push_back(root);
        <span class="hljs-keyword">int</span> lr = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(!q.empty()){
            <span class="hljs-keyword">int</span> q_long = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
            lr *= <span class="hljs-number">-1</span>;
            <span class="hljs-keyword">while</span>(q_long--){
                <span class="hljs-keyword">if</span>(lr == <span class="hljs-number">1</span>){
                    <span class="hljs-keyword">if</span>(q.front()-&gt;left) q.push_back(q.front()-&gt;left);
                    <span class="hljs-keyword">if</span>(q.front()-&gt;right) q.push_back(q.front()-&gt;right);
                    temp.push_back(q.front()-&gt;val);
                    q.pop_front();
                }
                <span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">if</span>(q.back()-&gt;right) q.push_front(q.back()-&gt;right);
                    <span class="hljs-keyword">if</span>(q.back()-&gt;left) q.push_front(q.back()-&gt;left);
                    temp.push_back(q.back()-&gt;val);
                    q.pop_back();
                }
            }
            ans.push_back(temp);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="234-a-nametreepathsuma%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E5%9B%9E%E6%BA%AF-treepathsum">2.34. <a name='treePathSum'></a>二叉树中和为某一值的路径(回溯) treePathSum</h3>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tem;
    <span class="hljs-keyword">int</span> cur_sum = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span></span>{
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;
        tem.push_back(root-&gt;val);
        <span class="hljs-keyword">if</span>(root-&gt;val == sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) {ans.push_back(tem);}
        dfs(root-&gt;left, sum-root-&gt;val);
        dfs(root-&gt;right, sum-root-&gt;val);

        tem.pop_back();
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>{
        dfs(root, sum);
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="235-a-nameverifysequenceofbsta%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-verifysequenceofbst">2.35. <a name='verifySequenceOfBST'></a>二叉搜索树的后序遍历序列 verifySequenceOfBST</h3>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
如果是则返回true，否则返回false。<br>
假设输入的数组的任意两个数字都互不相同。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>{
        <span class="hljs-keyword">return</span> verify(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verify</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; sequence, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> e)</span></span>{
        <span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// e是根节点，判断根节点把数组分成左右两部分．</span>
        <span class="hljs-keyword">int</span> t = sequence[e];
        <span class="hljs-keyword">int</span> i = s;
        <span class="hljs-keyword">while</span>(sequence[i] &lt; t) i++;
        <span class="hljs-keyword">int</span> j = i;
        <span class="hljs-keyword">while</span>(sequence[i] &gt; t) i++;
        <span class="hljs-keyword">if</span>(i!= e) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> verify(sequence, s, j<span class="hljs-number">-1</span>) &amp;&amp; verify(sequence, j, e<span class="hljs-number">-1</span>);
    }
};
</div></code></pre>
<h3 id="236-a-nametreefindpath1a%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-treefindpath1">2.36. <a name='treeFindPath1'></a>二叉树中和为某一值的路径 treeFindPath1</h3>
<p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">findPath</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;
        findone(root, sum, temp);
        <span class="hljs-comment">// 若不要求从根节点开始找，就加上这两行；</span>
        <span class="hljs-comment">// findPath(root-&gt;left, sum);</span>
        <span class="hljs-comment">// findPath(root-&gt;left, sum);</span>
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findone</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;temp)</span></span>{
        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span>(sum-root-&gt;val == <span class="hljs-number">0</span> &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) {
            temp.push_back(root-&gt;val);
            ans.push_back(temp);
        }
        <span class="hljs-keyword">else</span>{
            sum -= root-&gt;val;
            temp.push_back(root-&gt;val);
            findone(root-&gt;left, sum, temp);
            findone(root-&gt;right, sum, temp);
        }
        temp.pop_back();
    }
};
</div></code></pre>
<h3 id="237-a-name-1a%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%BB">2.37. <a name='-1'></a>复杂链表的复刻</h3>
<p>请实现一个函数可以复制一个复杂链表。
在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * Definition for singly-linked list with a random pointer.
 * struct ListNode {
 *     int val;
 *     ListNode *next, *random;
 *     ListNode(int x) : val(x), next(NULL), random(NULL) {}
 * };
 */</span>

</div></code></pre>
<h3 id="238-a-namestrtointa%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97-strtoint">2.38. <a name='strToInt'></a>字符串转数字 strToInt</h3>
<p>忽略所有行首空格，找到第一个非空格字符，可以是 ‘+/−’ 表示是正数或者负数，紧随其后找到最长的一串连续数字，将其解析成一个整数；
整数后可能有任意非数字字符，请将其忽略；
如果整数长度为0，则返回0；
如果整数大于INT_MAX(2^31 − 1)，请返回INT_MAX；如果整数小于INT_MIN(−2^31) ，请返回INT_MIN；</p>
<pre class="hljs"><code><div>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>{
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//去空格</span>
        <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[k] == <span class="hljs-string">' '</span>) k++;
        <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//判正负</span>
        <span class="hljs-keyword">if</span> (str[k] == <span class="hljs-string">'+'</span>) k++;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[k] == <span class="hljs-string">'-'</span>) k++, is_minus = <span class="hljs-literal">true</span>;
        <span class="hljs-comment">//字符变数字</span>
        <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str[k] &lt;= <span class="hljs-string">'9'</span>) {
            num = num * <span class="hljs-number">10</span> + str[k] - <span class="hljs-string">'0'</span>;
            k++;
        }
        <span class="hljs-comment">//处理特例</span>
        <span class="hljs-keyword">if</span> (is_minus) num *= <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span> (num &gt; INT_MAX) num = INT_MAX;
        <span class="hljs-keyword">if</span> (num &lt; INT_MIN) num = INT_MIN;
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)num;
    }
};
</div></code></pre>
<h3 id="239-a-namelastremaininga%E7%BA%A6%E7%91%9F%E5%A4%AB%E5%9D%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84-lastremaining">2.39. <a name='lastRemaining'></a>约瑟夫坏（圆圈中最后剩下的） lastRemaining</h3>
<h4 id="2391-a-namel1a%E6%9A%B4%E5%8A%9B%E6%A8%A1%E6%8B%9F-l1">2.39.1. <a name='l1'></a>暴力模拟 l1</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ve; 
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) ve.push_back(i);
        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (ve.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (ve.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) {
                t++;
                <span class="hljs-keyword">if</span> (t == ve.<span class="hljs-built_in">size</span>()) t = <span class="hljs-number">0</span>;
            }
            ve.erase(ve.<span class="hljs-built_in">begin</span>() + t);
            <span class="hljs-keyword">if</span> (t == ve.<span class="hljs-built_in">size</span>()) t = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> ve[<span class="hljs-number">0</span>];

    }
};
</div></code></pre>
<h4 id="2392-a-namel2a%E9%80%92%E6%8E%A8-l2">2.39.2. <a name='l2'></a>递推 l2</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> (lastRemaining(n - <span class="hljs-number">1</span>, m) + m) % n;
    }
};
</div></code></pre>
<h3 id="240-a-nameiscontinuousa%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90-iscontinuous">2.40. <a name='isContinuous'></a>扑克牌顺子 isContinuous</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isContinuous</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>{
		<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; se;
		<span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">int</span> mint = INT_MAX, maxt = INT_MIN;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
			mint = <span class="hljs-built_in">min</span>(mint, nums[i]);
			maxt = <span class="hljs-built_in">max</span>(maxt, nums[i]);

			<span class="hljs-keyword">if</span> (se.count(nums[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">else</span> se.insert(nums[i]);
		}
		<span class="hljs-keyword">return</span> maxt - mint &lt;= <span class="hljs-number">4</span>;
	}
};
</div></code></pre>
<h3 id="241-a-nameroutera%E4%B8%80%E6%8E%92%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96%E7%9A%84%E4%BF%A1%E5%8F%B7-router">2.41. <a name='Router'></a>一排路由器可以覆盖的信号 Router</h3>
<p>一条直线上等距离放置了n台路由器。路由器自左向右从1到n编号。第i台路由器到第j台路由器的距离为| i-j |。
每台路由器都有自己的信号强度，第i台路由器的信号强度为ai。所有与第i台路由器距离不超过ai的路由器可以收到第i台路由器的信号
（注意，每台路由器都能收到自己的信号）。问一共有多少台路由器可以收到至少k台不同路由器的信号。<a href="https://www.nowcoder.com/profile/1334434/codeBookDetail?submissionId=86144859">https://www.nowcoder.com/profile/1334434/codeBookDetail?submissionId=86144859</a></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n, k;
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ve</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-built_in">cin</span> &gt;&gt; ve[i];
    }
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">anst</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> l = i - ve[i], r = i + ve[i];
        <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span>) anst[l]++; <span class="hljs-keyword">else</span> anst[<span class="hljs-number">0</span>]++;
        <span class="hljs-keyword">if</span> (r &gt;= n - <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>; <span class="hljs-keyword">else</span> anst[r + <span class="hljs-number">1</span>]--;
    }
    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : anst) {
        temp += i;
        <span class="hljs-keyword">if</span> (temp &gt;= k) ans++;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; ans;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="242-a-nameslidea%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-slide">2.42. <a name='slide'></a>滑动窗口最大值 slide</h3>
<p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。
例如，如果输入数组[2, 3, 4, 2, 6, 2, 5, 1]及滑动窗口的大小3, 那么一共存在6个滑动窗口，它们的最大值分别为[4, 4, 6, 6, 6, 5]。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> };
    <span class="hljs-keyword">int</span> k = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
    <span class="hljs-comment">//记录下标</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
        <span class="hljs-comment">//当前最大值坐标不在范围里，移除</span>
        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; q.front() &lt; i - k + <span class="hljs-number">1</span>) q.pop_front();
        <span class="hljs-comment">// 单调队列</span>
        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] &gt; nums[q.back()]) q.pop_back();
        q.push_back(i);
        <span class="hljs-keyword">if</span> (i &gt;= k<span class="hljs-number">-1</span>) ans.push_back(nums[q.front()]);
    }
 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">','</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>###　股票最大利润 maxShares
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDiff</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> mint = INT_MAX;
        <span class="hljs-keyword">int</span> ans = INT_MIN;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            mint = <span class="hljs-built_in">min</span>(mint, nums[i]);
            ans = <span class="hljs-built_in">max</span>(ans, nums[i] - mint);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="243-a-namebia0a1an-1a%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84-bia0%C3%97a1%C3%97an-1">2.43. <a name='BiA0A1An-1'></a>乘积数组 B[i]=A[0]×A[1]…×A[n-1]</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (A.empty()) <span class="hljs-keyword">return</span> ans;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) {
            t *= A[i];
            ans.push_back(t);

        }
        t = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
            ans[i] = t * ans[i - <span class="hljs-number">1</span>];
            t *= A[i];
        }
        ans[<span class="hljs-number">0</span>] = t;
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="244-a-namemaxproducta%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-maxproduct">2.44. <a name='maxProduct'></a>分裂二叉树最大乘积 maxProduct</h3>
<p>给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。<br>
由于答案可能会很大，请你将结果对 10 ^ 9 + 7 取模后再返回。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = root-&gt;val + dfs(root-&gt;left) + dfs(root-&gt;right);
        temp.push_back(res);
        <span class="hljs-keyword">return</span> res;
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> v = dfs(root);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t : temp) {
            <span class="hljs-comment">// cout&lt;&lt;t&lt;&lt;' ';</span>
            ans = <span class="hljs-built_in">max</span>(ans, t * (v - t));
        }
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)ans % (<span class="hljs-keyword">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);
    }
};
</div></code></pre>
<h3 id="245-a-namelowestcommonancestor1a%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-lowestcommonancestor1">2.45. <a name='lowestCommonAncestor1'></a>二叉树最低公共祖先 lowestCommonAncestor1</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;
        <span class="hljs-keyword">auto</span> left = lowestCommonAncestor(root-&gt;left, p, q);
        <span class="hljs-keyword">auto</span> right = lowestCommonAncestor(root-&gt;right, p, q);
        <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;
        <span class="hljs-keyword">if</span> (left) <span class="hljs-keyword">return</span> left;
        <span class="hljs-keyword">return</span> right;
    }
};
</div></code></pre>
<h3 id="246-a-namebigmutiplea%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98-bigmutiple">2.46. <a name='BigMutiple'></a>大数相乘 BigMutiple</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">BigMutiple</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num1, <span class="hljs-built_in">string</span> num2)</span> </span>{
    <span class="hljs-built_in">string</span> res = <span class="hljs-string">""</span>;
    <span class="hljs-comment">//两个数的位数</span>
    <span class="hljs-keyword">int</span> m = num1.<span class="hljs-built_in">size</span>(), n = num2.<span class="hljs-built_in">size</span>();
    <span class="hljs-comment">//一个i位数乘以一个j位数，结果至少是i+j-1位数</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(m + n - <span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-comment">//每一位进行笛卡尔乘法</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> a = num1[i] - <span class="hljs-string">'0'</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
            <span class="hljs-keyword">int</span> b = num2[j] - <span class="hljs-string">'0'</span>;
            tmp[i + j] += a * b;
        }
    }
    <span class="hljs-comment">//进行进位处理，注意左侧是大右侧是小</span>
    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">int</span> t = tmp[i] + carry;
        tmp[i] = t % <span class="hljs-number">10</span>;
        carry = t / <span class="hljs-number">10</span>;
    }
    <span class="hljs-comment">//若遍历完仍然有进位</span>
    <span class="hljs-keyword">while</span> (carry != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">int</span> t = carry % <span class="hljs-number">10</span>;
        carry /= <span class="hljs-number">10</span>;
        tmp.insert(tmp.<span class="hljs-built_in">begin</span>(), t);
    }
    <span class="hljs-comment">//将结果存入到返回值中</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : tmp) {
        res = res + to_string(a);
    }
    <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; res[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-comment">//测试函数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">string</span> num1, num2;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2) {
        <span class="hljs-built_in">cout</span> &lt;&lt; BigMutiple(num1, num2) &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="247-a-namebigadda%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0-bigadd">2.47. <a name='bigAdd'></a>大数相加 bigAdd</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; b)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>(), m = b.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span>(n &lt; m) <span class="hljs-keyword">return</span> add(b, a);

    <span class="hljs-built_in">string</span> c; 
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tem;
    <span class="hljs-comment">// 数位和，两个加数对应的数位都加到 sum 上  </span>
    <span class="hljs-comment">// 0 &lt;= sum &lt;= 19</span>
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        sum += a[i] - <span class="hljs-string">'0'</span>;        
        <span class="hljs-keyword">if</span>(i &lt; m) sum += b[i] - <span class="hljs-string">'0'</span>;
        tem.push_back(sum % <span class="hljs-number">10</span>); <span class="hljs-comment">// 获取该数位的数字</span>
        sum /= <span class="hljs-number">10</span>;             <span class="hljs-comment">// 获取进位信息</span>
    }
    <span class="hljs-keyword">if</span>(sum) tem.push_back(sum);  <span class="hljs-comment">// 最高位的进位处理</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : tem) {
        c = c + to_string(a);
    }
    <span class="hljs-keyword">return</span> c;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">string</span> num1, num2;
    
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2) {
        reverse(num1.<span class="hljs-built_in">begin</span>(), num1.<span class="hljs-built_in">end</span>());
        reverse(num2.<span class="hljs-built_in">begin</span>(), num2.<span class="hljs-built_in">end</span>());
        <span class="hljs-built_in">string</span> anst = add(num1, num2);
        <span class="hljs-built_in">string</span> ans = <span class="hljs-built_in">string</span>(anst.rbegin(), anst.rend());
        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="248-a-namebitopadda%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95-bitopadd">2.48. <a name='bitopAdd'></a>不用加减乘除做加法 bitopAdd</h3>
<p>A + B 分为2个部分，A^B是不进位加法，(A&amp;B) &lt;&lt; 1是进位，二者相加就起到了相同的作用。
因为A + B = A^B + ((A&amp;B) &lt;&lt; 1)，所以说 还是会用到加号+，对此我们的解决方案是 使用一个while()循环，
不断迭代赋值，将 异或的结果和进位的结果分别变成a和b，因为b不断左移，所以总有一天会变成0，这时候while就跳出来。
答案一直存储在a里面，也就是异或(不进位加法)中，最后进位b=0，a没有必要进位了，答案就是最后的a。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-keyword">while</span> (b)
        {
            <span class="hljs-keyword">int</span> sum = a ^ b;
            <span class="hljs-keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;
            a = sum;
            b = carry;
        }

        <span class="hljs-keyword">return</span> a;
    }
};
</div></code></pre>
<h2 id="3-a-nameleetcodealeetcode">3. <a name='LeetCode'></a>LeetCode</h2>
<h3 id="31-a-nametwosuma1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-twosum">3.1. <a name='twoSum'></a>1.两数之和 twoSum</h3>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。题目<a href="https://leetcode-cn.com/problems/two-sum/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; heap;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span>(heap.count(target-nums[i])) <span class="hljs-keyword">return</span> {i, heap[target-nums[i]]};
            heap[nums[i]] = i;
        }
        <span class="hljs-keyword">return</span> {};
    }
};
</div></code></pre>
<h3 id="32-a-nameaddtwonumbersa2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-addtwonumbers">3.2. <a name='addTwoNumbers'></a>2. 两数相加 addTwoNumbers</h3>
<p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。<a href="https://leetcode-cn.com/problems/add-two-numbers/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        <span class="hljs-comment">// 记录该位的和 </span>
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
        ListNode *cur = dummy;
        <span class="hljs-keyword">while</span>(l1 || l2 || sum)
        {
            <span class="hljs-keyword">if</span>(l1) {sum += l1-&gt;val; l1 = l1-&gt;next;}
            <span class="hljs-keyword">if</span>(l2) {sum += l2-&gt;val; l2 = l2-&gt;next;}
            <span class="hljs-keyword">auto</span> temp = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);
            sum /=<span class="hljs-number">10</span>;
            cur = cur-&gt;next = temp;
        }
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }
};
</div></code></pre>
<h3 id="33-a-namelengthoflongestsubstringa3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-lengthoflongestsubstring">3.3. <a name='lengthOfLongestSubstring'></a>3. 无重复字符的最长子串 lengthOfLongestSubstring</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; heap;
        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !heap.count(s[right])){
                heap.insert(s[right]);
                ans = <span class="hljs-built_in">max</span>(ans, right-i+<span class="hljs-number">1</span>);
                right++;
            }
            heap.erase(s[i]);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="34-a-namefindmediansortedarraysa4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-findmediansortedarrays">3.4. <a name='findMedianSortedArrays'></a>4. 寻找两个正序数组的中位数 findMedianSortedArrays</h3>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
        <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heap;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>()+nums2.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span>(n1&gt;=nums1.<span class="hljs-built_in">size</span>()){
                heap.push_back(nums2[n2]);
                n2++;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n2&gt;=nums2.<span class="hljs-built_in">size</span>()){
                heap.push_back(nums1[n1]);
                n1++;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[n1] &lt; nums2[n2]){
                heap.push_back(nums1[n1]);
                n1++;
            }
            <span class="hljs-keyword">else</span>{
                heap.push_back(nums2[n2]);
                n2++;
            }
        }
        <span class="hljs-keyword">if</span>((n1 + n2)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> heap[(n1+n2)/<span class="hljs-number">2</span>];
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (heap[(n1+n2)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>] + heap[(n1+n2)/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;
    }
};
</div></code></pre>
<h3 id="35-a-namelongestpalindromea5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-longestpalindrome">3.5. <a name='longestPalindrome'></a>5. 最长回文子串 longestPalindrome</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
   
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> ans[<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>{
        <span class="hljs-comment">// 如果合理，计算；</span>
        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i] == s[j]){
            <span class="hljs-keyword">if</span>((j-i) &gt; ans[<span class="hljs-number">1</span>] -ans[<span class="hljs-number">0</span>]){
                ans[<span class="hljs-number">0</span>] = i;
                ans[<span class="hljs-number">1</span>] = j;
            }
            i--;
            j++;
        }
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
            help(s, i, i);
            help(s, i, i+<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> s.substr(ans[<span class="hljs-number">0</span>], ans[<span class="hljs-number">1</span>]-ans[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);
    }
};
</div></code></pre>
<h3 id="36-a-namezzconverta6-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-zconvert">3.6. <a name='ZzConvert'></a>6. Z 字形变换 zConvert</h3>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<a href="https://leetcode-cn.com/problems/zigzag-conversion/">website</a>
L   C   I   R
E T O E S I I G
E   D   H   N</p>
<pre class="hljs"><code><div>\\ 找规律
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> numRows)</span> </span>{
        <span class="hljs-built_in">string</span> ans;
        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;numRows; i++){
            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> || i== numRows<span class="hljs-number">-1</span>){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j&lt;s.<span class="hljs-built_in">size</span>(); j += <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>){
                    ans+=s[j];
                }
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i, z = <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>-i; j&lt;s.<span class="hljs-built_in">size</span>()||z&lt;s.<span class="hljs-built_in">size</span>(); j+=<span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span>, z+= numRows*<span class="hljs-number">2</span><span class="hljs-number">-2</span>){
                    <span class="hljs-keyword">if</span>(j&lt;s.<span class="hljs-built_in">size</span>())ans+=s[j];
                    <span class="hljs-keyword">if</span>(z&lt;s.<span class="hljs-built_in">size</span>())ans+=s[z];
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="37-a-nameintreversea7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-intreverse">3.7. <a name='intReverse'></a>7. 整数反转 intReverse</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<a href="https://leetcode-cn.com/problems/reverse-integer/">website</a></p>
<pre class="hljs"><code><div>\\转换为字符串（to_string-&gt;atoi）或者：
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(x){
            ans *= <span class="hljs-number">10</span>;
            ans += x%<span class="hljs-number">10</span>;
            x /= <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">if</span>(ans&lt;INT_MIN || ans &gt;INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="38-a-nameatoia8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi">3.8. <a name='atoi'></a>8. 字符串转换整数 (atoi)</h3>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止.<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> k =<span class="hljs-number">0</span>; 
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(k&lt;s.<span class="hljs-built_in">size</span>() &amp;&amp; s[k]==<span class="hljs-string">' '</span>) k++;

        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">'-'</span>) flag = <span class="hljs-number">-1</span>, k++;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">'+'</span>) k++;

        <span class="hljs-keyword">while</span>(k&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;(s[k]&gt;=<span class="hljs-string">'0'</span> &amp;&amp; s[k] &lt;= <span class="hljs-string">'9'</span>)){
            ans*=<span class="hljs-number">10</span>;
            ans+=(s[k]-<span class="hljs-string">'0'</span>);
            k++;
            <span class="hljs-keyword">if</span>(ans&gt;INT_MAX &amp;&amp; flag==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INT_MAX;
            <span class="hljs-keyword">if</span>(ans&gt;INT_MAX &amp;&amp; flag==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> INT_MIN;
        } 
        <span class="hljs-keyword">return</span> flag * ans;
    }
};
</div></code></pre>
<h3 id="39-a-nameispalindrome1a9-%E5%9B%9E%E6%96%87%E6%95%B0-ispalindrome1">3.9. <a name='isPalindrome1'></a>9. 回文数 isPalindrome1</h3>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<a href="https://leetcode-cn.com/problems/palindrome-number/">website</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        <span class="hljs-built_in">string</span> s1 = to_string(x);
        <span class="hljs-comment">// string s2 = to_string(x);</span>
        <span class="hljs-comment">// reverse(s1.begin(), s1.end());</span>
        <span class="hljs-built_in">string</span> s2 = <span class="hljs-built_in">string</span>(s1.rbegin(), s1.rend());
        <span class="hljs-keyword">return</span> s1 == s2;
    }
};
</div></code></pre>
<h3 id="310-a-nameismatchqa10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-ismatch-q">3.10. <a name='isMatchq'></a>10. 正则表达式匹配 isMatch q</h3>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>{
        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = p.<span class="hljs-built_in">size</span>();
        s = <span class="hljs-string">' '</span> +s; p = <span class="hljs-string">' '</span> + p;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(m+<span class="hljs-number">1</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>; j &lt;= m; j++){
                <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt;= m &amp;&amp; p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">if</span>(i &amp;&amp; p[j] != <span class="hljs-string">'*'</span>){
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; (s[i] == p[j] || p[j] ==<span class="hljs-string">'.'</span>);
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-string">'*'</span>){
                    dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || i &amp;&amp; dp[i<span class="hljs-number">-1</span>][j] &amp;&amp; (s[i] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">'.'</span>);
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[n][m];
    }
};
</div></code></pre>
<h2 id="4-a-namelandproblema%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-land-problem">4. <a name='landproblem'></a>岛屿问题 land problem</h2>
<h3 id="41-a-namenumislandsa%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-numislands">4.1. <a name='numIslands'></a>岛屿数量 numIslands</h3>
<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>{
        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;
        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j&lt;m; j++){
                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">'1'</span>){
                    dfs(grid, n, m, i ,j);
                    ans++;
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>{
        <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=n||c&lt;<span class="hljs-number">0</span>||c&gt;=m||grid[r][c]==<span class="hljs-string">'0'</span>) <span class="hljs-keyword">return</span>;
        grid[r][c] = <span class="hljs-string">'0'</span>;
        dfs(grid, n, m, r<span class="hljs-number">-1</span>, c);
        dfs(grid, n, m, r+<span class="hljs-number">1</span>, c);
        dfs(grid, n, m, r, c<span class="hljs-number">-1</span>);
        dfs(grid, n, m, r, c+<span class="hljs-number">1</span>);
    }
};
</div></code></pre>
<h3 id="42-a-namemaxareaofislanda%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-maxareaofisland">4.2. <a name='maxAreaOfIsland'></a>岛屿的最大面积 maxAreaOfIsland</h3>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt;grid.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++){
                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;
                dfs(grid, i, j, temp);
                ans = <span class="hljs-built_in">max</span>(ans, temp);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> &amp;temp)</span></span>{
        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&lt;<span class="hljs-number">0</span>||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()||grid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">else</span>{grid[i][j]=<span class="hljs-number">0</span>; temp++;}
        dfs(grid, i<span class="hljs-number">-1</span>, j, temp);
        dfs(grid, i+<span class="hljs-number">1</span>, j, temp);
        dfs(grid, i, j<span class="hljs-number">-1</span>, temp);
        dfs(grid, i, j+<span class="hljs-number">1</span>, temp);
    }
};
</div></code></pre>
<h3 id="43-a-nameislandperimetera%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF-islandperimeter">4.3. <a name='islandPerimeter'></a>岛屿的周长 islandPerimeter</h3>
<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{
        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j&lt;m; j++){
                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) {
                    ans += <span class="hljs-number">4</span>;
                    <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; grid[i<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span>) ans -= <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; grid[i][j<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>) ans -= <span class="hljs-number">2</span>;
                }
            }
        }s
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>

</body>
</html>
